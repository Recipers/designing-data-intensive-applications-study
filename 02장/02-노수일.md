# 2. 데이터 모델과 질의 언어
- 데이터 모델은 소프트웨어가 어떻게 작성됐는지, 해결하려는 문제를 어떻게 생각하는지에 대해서도 지대한 영향을 미침
- 대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 두어 만듬
- 각 계층의 핵심적인 문제는 다음 하위 계층 관점에서 데이터 모델을 표현하는 방법
    - 애플리케이션 개발자는 현실구조를 다루는 API를 모델링함
    - 데이터 구조를 저장할 때는 JSON이나 XML 문서, 관계형 데이터베이스 테이블이나 그래프 모델 같은 범용 데이터 모델로 표현
    - 데이터베이스 소프트웨어를 개발하는 엔지니어는 JSON/XML/관계형/그래프 데이터를 메모리나 디스크 또는 네트워크 상의 바이트 단위로 표현하는 방법을 결정, 다양한 방법으로 질의, 탐색, 조작 처리
    - 더 낮은 수준에서 하드웨어 엔지니어는 전류, 빛의 파동, 자기장 등의 관점에서 바이트를 표현하는 방법을 알아냄
- 복잡한 애플리케이션에서는 여러 API를 기반으로 만든 API처럼 중간 단계를 더 둘수는 있지만 기본 개념은 동일
    - 각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨김
    - 다른 그룹 사람들이 효율적으로 함께 일할수 있게끔 함
- 다양한 유형의 데이터 모델이 있고 각 데이터 모델은 사용 방법에 대한 가정을 나타냄
    - 사용법이 쉽거나, 어떤 동작을 지원하지 않거나, 빠르거나 느리게 작동, 어떤 데이터 변환은 자연스럽거나 부자연스러움
- 하나의 데이터 모델만을 완전히 익히는데도 많은 노력이 필요함
    - 데이터 모델은 그 위에서 소프트웨어가 할 수 있는 할과 할 수 없는 일에 영향을 주므로 애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상탕히 중요함
## 관계형 모델과 문서 모델
- 현재 가장 잘 알려진 데이터 모델은 에드가 코드가 제안한 관계형 모델을 기반으로 한 SQL
    - 데이터는 관계로 구성되고 각 관계는 순서 없는 튜플 모음
- 1980년대 중반에 관계형 데이터베이스 관리 시스템(RDBMS)과 SQL은 정규화된 구조로 데이터를 저장하고 질의할 사람들이 선택
- 관계형 데이터베이스의 근원은 메인프레임 컴퓨터에서 수행된 비즈니스 데이터 처리에 있음
    - 트랜잭션 처리, 일괄 처리
- 관계형 모델의 목표는 정리된 인터페이스 뒤로 구현 세부 사항을 숨기는 것
- 수년 동안 데이터 저장과 질의를 위해 많은 접근 방식이 경쟁
    - 1970년대와 1980년대 초반 : 네트워크 모델, 계층 모델이 주요 대안, 관계형 모델이 결국 우위
    - 1980년대 후반과 1990년 초반 : 객체 데이터베이스가 나타났다 사라짐
    - 2000년대 초반 : XML 데이터베이스 등장, 적게 채택됨
- 관계형 데이터베이스가 비즈니스 데이터 처리라는 본래 영역을 넘어 폭넓은 다양한 사용 사례에도 보편화 됨
### NoSQL의 탄생
- 관계형 모델의 우위를 뒤짚으려는 가장 최신 시도
- 2009년에 오픈소스, 분산 환경, 비관계형 데이터베이스 밋업용 인기 트위터 해시태그였음
    - Not Only SQL로 재해석 됨
- NoSQL 데이터베이스를 채택한 다양한 원동력
    - 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요
    - 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
    - 관계형 모델에서 지원하지 않는 특수 질의 동작
    - 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바램
- 가까운 미래에는 관계형 데이터베이스가 폭넓은 다양함을 가진 비관계형 데이터스토어와 함께 사용될 것
    - 다중 저장소 지속성
### 객체 관계형 불일치
- 대부분의 애플리케이션은 객체지향 프로그래밍 언어로 개발
    - 데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체 사이에 (거추장스러운) 전환 계층이 필요
    - 모델 사이의 분리를 **임피던스 불일치**라고 부름
- 액티브레코드, 하이버네이트 같은 객체 관계 매핑 프레임워크는 전환 계층에 필요한 상용구 코드의 양을 줄이지만, 두 모델 간의 차이를 완벽히 숨길 순 없음
- 예시 : 사용자(users)와 사용자 정보의 일대다 관계를 나타내는 방법
    - 전통적인 SQL 모델에서 가장 일반적인 정규화 표현은 직위, 학력, 연락처 정보를 개별 테이블에 놓고 users 테이블을 참조
    - SQL 표준의 마지막 버전에서 구조화된 데이터타입과 XML 데이터에 대한 지원을 추가, 단일 로우에 다중 값을 저장할 수 있고 문서 내 질의와 인덱스가 가능
    - 직업, 학력 연락처 정보를 JSON이나 XML 문서로 인코딩해 데이터베이스의 텍스트 칼럼에 저장한 다음, 애플리케이션이 구조와 내용을 해석, 인코딩된 칼럼의 값을 질의할 수 없음
    - 이력서 같은 데이터 구조는 모든 내용을 갖추고 있는 문서라서 JSON 표현에 매우 적합, 훨씬 더 간단
        - 몽고DB, 리싱크DB, 카우치DB, 에스프레소 같은 문서 지향 데이터베이스는 JSON 데이터 모델을 지원
- JSON 모델이 임피던스 불일치를 줄인다고 생각하지만 문제도 있음 (4장 내용)
- JSON 표현은 다중 테이블 스키마보다 더 나은 지역성을 가짐
    - 모든 관련 정보가 한 곳에 있어서 질의 하나로 충분
### 다대일과 다대다 관계
- 그림 2-1에서 region_id, industry_id는 ID로 주어짐
- 사용자 인터페이스 상, 지역과 업계를 입력하고 평문으로 저장하는 것도 합리적이지만, 표준 목록을 리스트나 자동완성으로 제공하는것의 장점
    - 프로필 간 일관된 스타일과 철자
    - 모호함 회피
    - 갱신의 편의성, 이름이 한 곳에만 저장되므로 변경해야 하는 경우 전반적으로 갱신하기 쉬움
    - 현지화 지원, 사이트를 다른 언어로 번역할 때 표준 목록을 현지화해 지역과 업계를 사이트를 보는 사람의 언어로 표시
    - 더 나은 검색
- ID나 텍스트 문자열의 저장 여부는 중복의 문제
- ID를 사용하는 장점으로 ID 자체는 아무런 의미가 없기 때문에 변경할 필요가 없음
    - 식별 정보를 변경해도 ID는 동일하게 유지 가능
    - 만약 정보가 중복돼 있으면 모든 중복 항목을 변경해야 하는데, 쓰기 오버헤드와 불일치 위험이 있음
    - 중복을 제거하는 일이 데이터베이스의 정규화 이면에 놓인 핵심 개념
- 중복된 데이터를 정규화하려면 다대일 관계가 필요한데, 다대일 관계는 문서 모델에 적합하지 않음
    - 관계형 데이터베이스에서는 조인이 쉽기 때문에 ID로 다른 테이블의 로우를 참조하는 방식이 일반적
    - 문서 데이터베이스에서는 일대다 트리 구조를 위해 조인이 필요하지 않지만, 조인에 대한 지원이 보통 약함
- 데이터베이스 자체가 조인을 지원하지 않으면 데이터베이스에 대한 다중 질의를 만들어서 애플리케이션 코드에서 조인을 흉내내야 함
- 초기 버전이 조인 없는 문서 모델에 적합하더라도 애플리케이션에 기능을 추가하면서 데이터는 점차 상호 연결되는 경향이 있음
### 문서 데이터베이스는 역사를 반복하고 있나?
- 관계형 데이터베이스는 일상적으로 다대다 관계와 조인을 사용
    - 문서 데이터베이스와 NoSQL은 다대다 관계를 표현하는 제일 좋은 방법에 대한 논쟁을 열음
- 1970년대 비즈니스 데이터 처리를 위해 가장 많이 사용한 데이터베이스는 IBM의 정보 관리 시스템(IMS)
    - 아폴로 우주 프로그램의 재고 관리 목적
    - 계층 모델이라 부르는 상당히 간단한 데이터 모델 사용
        - 계층 모델은 JSON 모델과 비슷함
        - 모든 데이터를 중첩된 레코드 트리로 표현
    - 일대다 관계에서 잘 동작
    - 다대다 관계 표현 어렵고, 조인을 지원하지 않음
- 계층 모델의 한계를 해결하기 위해 다양한 해결책 제안됨
    - 관계형 모델 -> SQL이 되어 세상을 지배
    - 네트워크 모델 -> 희미하게 잊혀짐
#### 네트워크 모델
- 코다실이라는 위원회에서 표준화, 코다실 모델
- 다양한 여러 데이터베이스 벤더가 네트워크 모델을 구현
- 계층 모델을 일반화함
- 레코드는 다중 부모가 있을 수 있음
- 다대일과 다대다 관계를 모델링할 수 있음
- 레코드 간 연결은 외래 키보다는 프로그래밍 언어의 포인터와 비슷
- 레코드에 접근하는 유일한 방법은 최상위 레코드에서부터 연속된 연결 경로를 따르는 방법
    - 접근 경로
- 가장 간단한 경우는 연결 목록의 순회와 같을 때
- 다대다 관계의 세계에서는 다양한 다른 경로가 같은 레코드로 이어질 수 있고 네트워크 모델을 사용하는 프로그래머는 경로의 맨 앞에서 다양한 접근 경로를 추적해야 함
- 레코드 목록을 반복해 접근 경로를 따라 데이터베이스의 끝에서 끝까지 커서를 움직여 수행
- 제한된 하드웨어 성능을 가장 효율적으로 사용할 수 있었지만, 데이터베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못함
- 접근 경로를 변경할 순 있지만, 많은 수작업 데이터 베이스 질의 코드를 봐야 하고, 새로운 접근 경로를 다루기 위해 재작성 해야함
#### 관계형 모델
- 관계형 모델이 하는 일은 모든 데이터를 배치하는 것
- 관계는 단순히 튜플의 컬렉션이 전부
- 테이블의 일부 또는 모든 로우를 선택해서 읽을 수 있고, 일부 칼럼을 키로 지정해 칼럼과 일치하는 특정 로우를 읽을 수 있음
- 다른 테이블과의 외래 키 관계에 대해 신경쓰지 않고 임의 테이블에 새 로우를 작성할 수 있음
- 질의 최적화기(query optimizer)는 질의의 어느 부분을 어떤 순서로 실행할지 결정하고 사용할 인덱스를 자동으로 결정
    - 이 선택이 실제로 접근 경로
    - 질의 최적화기가 자동으로 만듬
- 새로운 방식으로 데이터에 질의하고 싶은 경우 새로운 인덱스를 선언, 질의는 자동으로 적합한 인덱스를 선택
    - 새로운 인덱스를 사용하기 위해 질의를 바꿀 필요가 없음
    - 새로운 기능을 추가하기 쉬움
#### 문서 데이터베이스와의 비교
- 문서 데이터베이스는 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장
- 다대일과 다대다 관계를 표현할 때 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 다르지 않음
    - 고유한 식별자로 참조
        - 관계형 모델에서는 외래 키
        - 문서 모델에서는 문서 참조
        - 조인이나 후속 질의를 사용해 읽기 시점에 확인
### 관계형 데이터베이스와 오늘날의 문서 데이터베이스
- 관계형 데이터베이스와 문서 데이터베이스를 비교하는 경우, 내결함성과 동시성 처리를 포함해 고려해야 할 차이점이 많지만, 이번 장에서는 데이터 모델의 차이점에만 집중
- 문서 데이터 모델을 선호하는 주요 이유
    - 스키마 유연성
    - 지역성에 기안한 더 나은 성능
- 관계 모델의 대응
    - 조인, 다대일, 다대다 관계를 더 잘 지원
#### 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?
- 애플리케이션에서 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는 것이 좋음
    - 문서와 비슷한 구조를 여러 테이블로 나누어 찢는 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 애플리케이션 코드를 발생시킴
- 문서 모델에 제한이 있음
    - 문서 내 중첩 항목으로 바로 참조할 수는 없음
    - 문서가 너무 깊게 중첩되지 않으면 문제가 되지는 않음
- 애플리케이션이 다대다 모델을 사용한다면 문서 모델은 매력이 떨어짐
    - 비정규화로 조인의 필요성 줄이기는 가능, 일관성 유지위해 추가 작업 필요
    - 복잡도가 애플리케이션으로 이동, 데이터베이스 조인보다 느림, 나쁜 성능으로 이어짐
#### 문서 모델에서의 스키마 유연성
- 대부분의 문서 데이터베이스와 관계형 데이터베이스에서 지원하는 JSON은 스키마를 강요하지 않음
- 관계형 데이터베이스에서 제공하는 XML은 선택적으로 스키마 유효성 검사를 포함할 수 있음
- 스키마가 없다는 뜻은 임의의 키와 값을 문서에 추가하고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는다는 뜻
- 문서 데이터베이스는 스키마리스로 불리지만 오해의 소지가 있음
    - 데이터를 읽는 코드는 보통 구조의 유형을 어느 정도 가정
    - 암묵적인 스키마가 있지만 강요하지는 않음
    - 쓰기 스키마와 반대되는 읽기 스키마
- 읽기 스키마는 프로그래밍 언어에서 동적 타입 확인과 유사
- 스키마는 정적 타입 확인과 비슷
- 스키마 변경은 느리고 중단시간을 요구하기 때문에 평판이 나쁨
    - 하지만 그정도는 아님, MySQL은 예외 (ALTER TABLE 시, 전체 테이블 복사 이슈)
    - 큰 테이블에 UPDATE문을 실행하면 모든 로우가 재작성 될 수 있어 오래 걸림
- 읽기 스키마 접근 방식은 컬렉션 안의 항목이 어떤 이유로 모두 동일한 구조가 아닐 때 유리 (데이터가 여러 다른 유형으로 구성되어 있음)
    - 다른 여러 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체 테이블에 넣는 방법은 실용적이지 않다
    - 사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정
- 모든 레코드가 동일한 구조라서 예상 가능하다면 스키마가 문서화와 구조를 강제하기 위한 유용한 메커니즘임
#### 질의를 위한 데이터 지역성
- 문서는 보통 JSON, XML로 인코딩된 단일 연속 문자열이나 JSON 또는 XML의 이진 변형으로 저장됨
- 자주 전체 문서에 접근해야 할 때 저장소 지역성을 활용하면 성능 이점이 있음
    - 다중 테이블로 나워졌으면 검색하기 위해 다중 인덱스 검색이 필요, 더 많은 디스크 탐색 및 시간 소요
- 지역성의 이점은 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용됨
    - 문서의 작은 부분에만 접근해도 전체 문서를 적재해야 하기에 큰 문서에서는 낭비일 수 있음
    - 문서를 갱신할 때도 전체 문서를 재작성해야 함
    - 인코딩된 문서의 크기를 바꾸지 않는 수정은 쉽게 수행할 수 있음
    - 이런 이유로 문서의 크기가 증가하는 쓰기를 피하라고 권장함
    - 이런 성능 제한은 문서 데이터베이스가 유용한 상황이 많이 줄어드는 이유
- 지역성을 위해 관련 데이터를 함께 그룹화하는 개념이 문서 모델에만 국한되지 않음
    - 구글의 스패너 데이터베이스
        - 부모 테이블 내에 테이블의 로우를 교차 배치되게끔 선언하는 스키마를 허용, 관계형 데이터 모델에서 지역성 특성을 제공
    - 오라클의 다중 테이블 인덱스 클러스터 테이블
    - 빅테이블 데이터 모델의 칼럼 패밀리
#### 문서 데이터베이스와 관계형 데이터베이스의 통합
- 대부분의 관계형 데이터베이스 시스템은 (MySQL 제외) XML을 지원
    - XML 문서의 지역적 수정과 XML 문서 내부에서 인덱싱하고 질의하는 기능을 포함
- PostgreSQL, MySQL, IBM DB는 JSON 문서에 대해 비슷한 수준의 지원 기능을 제공
- 문서 데이터베이스 쪽에서
    - 리싱크 DB는 질의 언어에서 관계형 조인을 지원
    - 몽고DB 드라이버는 자동으로 데이터베이스 참조를 확인 (실제로는 클라이언트 측 조인 수행)
- 관계형 데이터베이스와 문서 데이터베이스는 시간이 지남에 따라 점점 더 비슷해지고 있음
## 데이터를 위한 질의 언어
- 관계형 모델이 등장했을 때 데이터를 질의하는 새로운 방법도 함께 나타남
    - SQL은 선언형 질의 언어
    - IMS, 코다실은 명령형 코드를 사용해 데이터베이스에 질의
- SQL을 정의할 때 관계 대수의 구조를 상당히 유사하게 잘 따름
- 명령형 언어는 특정 순서로 특정 연산을 수행하게끔 컴퓨터에 지시
- SQL이나 관계 대수 같은 선언형 질의 언어에서는 목표를 달성하기 위한 방법이 아니라 알고자 하는 데이터의 패턴, 결과가 충족해야 하는 조건과 데이터를 어떻게 변환할지를 결정하기만 하면 됨
    - 어떤 인덱스, 어떤 조인 함수, 어떤 순서로 실행할지는 쿼리 옵티마이저가 할 일
- 선언형 질의 언어는 명령형 API보다 더 간결하고 쉽게 작업할 수 있음
    - 데이터베이스 엔진의 상세 구현이 숨겨져 있어, 질의를 변경하지 않고도 데이터베이스 시스템의 성능을 향상시킬 수 있음
- SQL은 특정 순서를 보장하지 않음
- 명령형 코드는 코드가 순서에 의존하는지 여부를 확신할 수 없음
- 선언형 언어는 병렬 실행에 적합함
- 명령형 코드는 명령어를 특정 순서로 수행하게끔 지정하기 때문에 다중 코어나 다중 장비에서 병렬처리가 어려움
### 웹에서의 선언형 질의
- 선언형 질의 언어의 장점은 데이터베이스에만 국한되지 않음
    - CSS 선택자 `li.selected > p`
    - XSL XPath 표현식 `li[@class='selected']/p`
    - CSS와 XSL은 문서의 스타일을 지정하기 위한 선언형 언어
    - javascript 코어 DOM API 를 사용하면 코드량이 늘고, 이해하기 어렵고 문제가 많음
### 맵리듀스 질의
- 맵리듀스는 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델
- 몽고DB와 카우치DB를 포함한 일부 NoSQL 데이터 저장소는 제한된 형태의 맵리듀스를 지원
    - 많은 문서를 대상을 읽기 전용 질의를 수행할 때 사용
- 맵리듀스는 선언형 질의 언어도 완전한 명령형 질의 API도 아닌 그 중간 정도 에 있음
- 질의 로직은 처리 프레임워크가 반복적으로 호출하는 조각 코드로 표현
- 맵리듀스는 여러 함수형 프로그래밍 언어에 있는 map(collect)와 reduce(fold, inject) 함수를 기반으로 함
- 몽고DB의 map, reduce는 순수 함수여야 함
    - 입력으로 전달된 데이터만 사용
    - 추가적인 데이터베이스 질의를 수행할 수 없어야 함
    - 부수효과가 없어야 함
    - 임의 순서로 어디서나 실행, 장애가 발생해도 재실행 가능
- 클러스터링 환경에서 분산 실행을 위한 프로그래밍 모델인 맵리듀스는 상당히 저수준 프로그래밍 모델임
- SQL 같은 고수준 질의 언어도 맵리듀스 연산의 파이프라인으로 구현할 수 있지만 맵리듀스를 사용하지 않은 분산 SQL 구현도 많음
    - SQL에 단일 장비에서 수행되도록 제한한 것은 없으며, 맵리듀스가 분산 질의 실행에 대한 독점권을 가진 것도 아님
- 일부 SQL 데이터베이스도 javascript 함수로 확장될 수 있음
- 맵리듀스 사용성 문제는 연계된 javascript 함수 두 개를 신중하게 작성해야 함, 하나의 질의를 작성하는 것보다 어려움
- 선언형 질의 언어는 쿼리 옵티마이저가 성능을 높일 기회를 제공
- 몽고DB는 집계 파이프라인이라 부르는 선언형 질의 언어를 추가
## 그래프형 데이터 모델
- 데이터에서 다대다 관계가 매우 일반적이고, 데이터 간 연결이 복잡해지면 그래프로 데이터를 모델링 하는 것이 더 자연스러움
- 그래프는 두 유형의 객체로 이루어짐, 정점과 간선
- 그래프로 모델링하는 데이터 예시
    - 소셜 그래프
        - 정점은 사람, 간선은 사람들이 서로 알고 있음
    - 웹 그래프
        - 정점은 웹 페이지, 간선은 다른 페이지에 대한 링크
    - 도로나 철도 네트워크
        - 정점은 교차로, 간선은 교차로 간 도로나 철로ㅠ 선
- 그래프 상 동작하는 잘 알려진 알고리즘
    - 자동차 네비게이션 시스템
    - 페이지랭크
- 그래프 정점은 모두 같은 유형이 아닐 수 있음, 동종 데이터에 국한되지 않음
    - 페이스북은 다른 유형의 정점과 간선을 단일 그래프로 유지
        - 사람, 장소, 이벤트, 체크인, 코멘트
- 그래프에서 데이터를 구조화하고 질의하는 몇 가지 다른 방법이 있음
    - 책에서는 속성 그래프 모델과 트리플 저장소 모델을 설명
    - 그래프용 선언형 질의 언어 세 가지 살펴봄
        - 사이퍼
        - 스파클
        - 데이터로그
    - 이 밖에도 그렘린과 같은 명령형 그래프 질의 언어와 프리글 같은 그래프 처리 프레임워크가 있음
### 속성 그래프
- 속성 그래포 모델에서 정점은 다음의 요소로 구성됨
    - 고유한 식별자
    - 유출 간선 집합
    - 유입 간선 집합
    - 속성 컬렉션
- 각 간선은 다음의 요소로 구성
    - 고유한 식별자
    - 간선이 시작하는 정점 (꼬리 정점)
    - 간선이 끝나는 정점 (머리 정점)
    - 두 정점 간 관계 유형을 설명하는 레이블
    - 속성 컬렉션 (키-값 쌍)
- 이 모델의 중요한 면
    - 정점은 다른 정점과 간선으로 연결됨, 특정 유형과 관련 여부를 제한하는 스키마는 없음
    - 정점이 주어지면 정점의 유입과 간선을 효율적으로 찾을 수 있고 그래프를 순회할 수 있음, 일련의 정점을 따라 앞 뒤 방향으로 순회함
    - 다른 유형의 관계에서 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있음
- 그래프는 데이터 모델링을 위한 많은 유연성을 제공
- 전통적인 관계형 스키마에서 표현하기 어려운 사례 (그림 2-5)
    - 국가마다 지역 구조가 다름
        - 프랑스에서는 주, 도
        - 미국에서는 군, 주
- 예제에 있는 그림의 사람에 대한 여러 사실을 포함시키기 위해 그래프를 확장한다고 가정했을 때 
    - 그래프는 발전성이 좋아서 애플리케이션에 기능을 추가하는 경우 데이터 구조 변경을 수용하게끔 확장 가능
### 사이퍼 질의 언어
- 속성 그래프를 위한 선언형 질의 언어
- 네오포제이 그래프 데이터베이스용으로 만들어짐
### SQL의 그래프 질의
- 관계형 데이터베이스에서 그래프를 데이터로 표현할 수 있긴 하지만 어려움
- 관계형 데이터베이스에서는 대개 질의에 필요한 조인을 미리 알고 있음
- 그래프 질의에서는 찾고자 하는 정점을 찾기 전에 가변적인 여러 간선을 순회해야 함
    - 미리 조인 수를 고정할 수 없음
- 사이퍼에서 :WITHIN*0..는 "0회 이상 WITHIN 간선을 따라가라", 정규표현식의 * 연산자와 같음
- SQL:1999 이후로 가변 순회 경로에 대한 질의 개념은 재귀 공통 테이블 식 (WITH RECURSIVE)을 사용해서 표현할 수 있음
    - 문법이 매우 어려움
- 사이퍼는 4줄, SQL은 29줄
### 트리플 저장소와 스파클
- 트리플 저장소 모델은 속성 그래프 모델과 거의 동등함
- 모든 정보를 주어, 서술어, 목적어 처럼 매우 간단한 세 부분 구문 형식으로 저장
- 트리플의 주어는 그래프의 정점과 동등, 목적어는 두 가지 중 하나
    - 문자열이나 숫자 같은 원시 데이터타입의 값, 트리플의 서술어와 목적어는 주어 정점에서 속성의 키, 값과 동등함
    - 그래프의 다른 정점, 서술어는 그래프의 간선이고 주어는 꼬리 정점이며 목적어는 머리 정점
- 예제 2-6은 터틀 형식의 트리플로 작성됨
```
@prefix : <urn:example:>.
:lucy    a         :Person.
:lucy    :name     "Lucy".
:lucy    :bornIn   :idaho.
:idaho   a         :Location.
:idaho   :name     "Idaho".
:idaho   :type     "state".
:idaho   :within   :usa.
:usa     a         :Location.
:usa     :name     "United States".
:usa     :type     "country".
:usa     :within   :namerica.
:namerica a        :Location.
:namerica :name    "North America".
:namerica :type    "continent".
```
- 그래프 정점을 _:somName으로 작성, 외부의 것을 의미하지 않음
    - 같은 정점을 참조하는지 알지 못하기 때문에 존재
    - 서술어가 간선을 나타내면 목적어는 정점이 됨 `_:idaho :within _:usa`
    - 서술어가 속성이라면 목적어는 문자열 리터럴이 됨 `_:usa :name "United States"`
- 동일한 주어를 반복하는 작업은 단순 반복 작업
- 세미콜론을 활용해 동일한 주어에 대해 여러 경우를 표현할 수 있음
```
@prefix : <urn:example:>.

:lucy a :Person; :name "Lucy"; :bornIn :idaho.
:idaho a :Location; :name "Idaho"; :type "state"; :within :usa.
:usa a :Location; :name "United States"; :type "country"; :within :namerica.
:namerica a :Location; :name "North America"; :type "continent".
```
#### 시멘틱 웹
- 트리플 저장소에 관한 내용을 읽다보면 시멘틱 웹 관련 내용에 빠질수도 있는데, 시멘틱 웹과는 완전 독립적임
- 시멘틱 웹
    - 웹 사이트는 사람이 읽을 수 있는 텍스트와 그림으로 정보를 게시하고 있으니 컴퓨터가 읽게끔 기계가 판독 가능한 데이터로도 정보를 게시하는 것
- 자원 기술 프레임워크 (RDF)
    - 서로 다른 웹 사이트가 일관된 형식으로 데이터를 게시하기 위한 방법을 제안
    - 서로 다른 웹 사이트가 일종의 전 인터넷 "만물 데이터베이스"인 데이터 웹에 자동으로 결합할 수 있게 함
#### RDF 데이터 모델
- 터틀 언어는 RDF 데이터를 사람이 읽을 수 있는 형식으로 표현
    - 때로는 XML 형식으로 씀
- 인터넷 전체의 데이터 교환을 설계했기 때문에 이상한 점이 있음
    - 주어, 서술어 목적어는 주로 URI
    - 서술어는 WIHIN, LIVES_IN이 아니라 `<http://aaa.bb/cc#within>` 또는 `<http://aaa.bb/cc#lives_in>` 같은 URI일 수 있음
- URL는 반드시 실제 접속 가능한 주소일 피룡는 없음, 단순히 네임스페이스일 뿐
#### 스파클 질의 언어
- 스파클은 RDF 데이터 모델을 사용한 트리플 저장소 질의 언어
- 사이퍼보다 스파클에서 더욱 간결해질 수 있으며, 구조는 매우 유사
```
PREFIX : <urn:example:>

SELECT ?personName WHERE {
    ?person :name ?personName.
    ?person :bornIn / :within* / :name "United States".
    ?person :livesIn / :within* / :name "Europe".
}
```
- RDF는 속성과 간선을 구별하지 않고 서술어만 사용하기 때문에 속성 매칭을 위해 동일한 구문을 사용할 수 있음
### 초석: 데이터로그
- 데이터로그는 스파클이나 사이퍼보다 훨씬 오래된 언어, 1980년대 광범위하게 연구됨
- 소프트웨어에서는 잘 알려지지 않았지만, 질의 언어의 기반이 되는 초석을 제공
- 일부 데이터 시스템이서 데이터로그를 사용
    - 데이토믹은 데이터로그를 질의 언어로 사용
- 데이터로그의 데이터 모델은 트리플 저장소 모델과 유사하지만 조금 더 일반화됨
    - 서술어(주어, 목적어) 형태로 작성
```
name(namerica, 'North America').
type(namerica, continent).

name(usa, 'United States').
type(usa, country).
within(usa, namerica).

name(idaho, 'Idaho').
type(idaho, state).
within(idaho, usa).
name(lucy, 'Lucy').
born_in(lucy, idaho).
```
- 데이터로그는 프롤로그의 부분 집합
```
within_recursive(Location, Name) :- name(Location, Name).  /* 규칙 1 */

within_recursive(Location, Name) :- within(Location, Via),  /* 규칙 2 */
                                    within_recursive(Via, Name).

migrated(Name, BornIn, LivingIn) :- name(Person, Name),     /* 규칙 3 */
                                    born_in(Person, BornLoc),
                                    within_recursive(BornLoc, BornIn),
                                    lives_in(Person, LivingLoc),
                                    within_recursive(LivingLoc, LivingIn).

?- migrated(Who, 'United States', 'Europe').
```
- 사이퍼와 스파클은 SELECT로 바로 잘의
- 데이터로그는 단계를 나눠 조금씩 질의로 나아감
    - 새로운 서술어를 데이터베이스에 전달하는 규칙을 정의
        - 예제에서는 within_recursive와 migrated 두 개를 새로 정의
    - 서술어는 데이터베이스에 저장된 트리플이 아님
    - 데이터나 다른 규칙으로부터 파생됨
    - 규칙은 함수가 다른 함수를 호출하거나 재귀적으로 자신을 호출하는 것처럼 다른 규칙을 참조할 수 있음
- 규칙에서 대문자로 시작하는 단어는 변수
- 서술어는 사이퍼와 스파클의 서술어와 대응됨
    - name(Location, Name) 은 Location = namerica와 Name = 'North America'를 가진 트리플 name(namerica, 'North America')에 대응됨
- 시스템이 :- 연산자의 오른편에 있는 모든 서술어의 대응을 찾으면 규칙이 적용됨
- 규칙이 적용될 때 :- 왼편이 데이터베이스에 추가됨 (변수는 대응된 값으로 대체됨)
- 규직을 적용할 수 있는 방법
    - 데이터베이스에 name(namerica, 'North America')가 존재하면 규칙 1을 적용, 규칙 1은 within_recursive(namerica, 'North America')를 생성
    - 데이터베이스에 within(usa, namerica)가 존재하고 이전 단계에서 within_recursive(namerica, 'North America')를 생성했으면 규칙2를 적용, 규칙 2는 within_recursive(usa, 'North America')를 생성함
    - 데이터베이스에 within(idaho, usa)가 존재하고 이전 단계에서 within_recursive(usa, 'North America')를 생성했으면 규칙2를 적용, 규칙 2는 within_recursive(idaho, 'North America')를 생성
- within_recursive 서술어는 규칙 1과 2를 반복 적용해 데이터베이스에 포함된 북아메리카의 모든 위치를 찾을 수 있음
- 규칙 3으로 LivingIn 장소에 살면서 특정 BornIn 장소에서 태어난 사람을 찾을 수 있음
- 최종적으로 이전 사이퍼나 스파클 질의와 같은 답을 얻음
- 데이터로그 접근 방식은 질의 언어와는 다른 사고가 필요함
    - 다른 질의의 규칙을 결합하거나 재사용할 수 있기 때문에 매우 강력한 접근 방식
    - 일회성 질의에는 편리하진 않지만, 데이터가 복잡하면 더 효과적