- 오늘날 많은 애플리케이션은 계산 중심과는 다르게 데이터 중심적이다.
- 일반적으로 데이터 중심 애플리케이션은 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소로 만든다
  - 구동 애프릴케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장 (데이터베이스)
  - 읽기 속도 향상을 위해 값비싼 수행 결과를 기억 (캐시)
  - 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공 (검색 색인)
  - 비동기 처리를 위해 다른 프로세스로 메시지 보내기 (스트림 처리)
  - 주기적으로 대량의 누적된 데이터를 분석 (일괄 처리)
- 데이터 시스템은 성공적으로 추상화됐다. 애플리케이션을 만들 때 대부분의 엔지니어들은 처음부터 새로운 데이터 저장소 엔진을 작성하지 않는다. 데이터베이스가 데이터 저장 작업을 위해 더할 나위 없이 좋은 도구이기 때문이다.
- 하지만 현실은 그리 간단하지 않다. 애플리케이션마다 요구사항이 다르기 때문에 데이터베이스 시스템 또한 저마다 다양한 특성을 가지고 있다.
  - 캐싱을 위한 다양한 접근 방식과 검색 색인을 구축하는 여러 가지 방법 등이 있다.
  - 애플리케이션을 만들 때 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 한다.

# 데이터 시스템에 대한 생각
- 일반적으로 데이터베이스, 큐, 캐시 등을 매우 다른 범주에 속하는 도구로 생각한다. 이 둘은 표면적으로 비슷하더라도 매우 다른 접근 패턴을 갖고 있어 서로 다른 성능 특성이 있기 때문에 구현 방식이 매우 다르다.
- 그러면 모든 것을 왜 데이터시스템이라는 포괄적 용어로 묶어야 할까?
  - 데이터 저장과 처리를 위한 여러 새로운 도구는 최근에 만들어졌다. 새로운 도구들은 다양한 사용 사례에 최적화됐기 때문에 더 이상 전통적인 분류에 딱 들어맞지 않는다.
  - 점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 갖고 있다.
    - 대신 작업은 단일 도구에서 효율적으로 수행할 수 있는 태스크로 나누고 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결한다.

<img width="537" alt="스크린샷 2025-07-01 오후 5 16 58" src="https://github.com/user-attachments/assets/fb6f9fd5-edc8-4ec7-8221-771e0b12e30d" />

- 서비스 제공을 위해 각 도구를 결합할 때 서비스 인터페이스나 API는 보통 클라이언트가 모르게 구현 세부 사항을 숨긴다.
  - 기본적으로 좀 더 작은 범용 구성 요소들로 새롭고 특수한 목적의 데이터 시스템을 만든다.
  - 복합 데이터 시스템은 외부 클라이언트가 일관된 결과를 볼 수 있게끔 쓰기에서 캐시를 올바르게 무효화하거나 업데이트하는 등의 보장 기능을 제공할 수 있다.
- 데이터 시스템이나 서비스를 설계할 때 까다로운 문제가 많이 생긴다.
  - 내부적으로 문제가 있더라도 데이터를 정확하고 완전하게 유지하려면 어떻게 해야 할까?
  - 시스템의 일부 성능이 저하되더라도 클라이언트에 일관되게 좋은 성능을 어떻게 제공할 수 있을까?
  - 부하 증가를 다루기 위해 어떻게 규모를 확장할까?
  - 서비스를 위해 좋은 API는 어떤 모습일까?
- 이 책에서는 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점을 둔다.
  - 신뢰성
    - 하드웨어나 소프트웨어 결함, 심지어 인적 오류 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야 한다.
  - 확장성
    - 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.
  - 유지보수성
    - 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업(현재 작업을 유지보수하고 새로운 사용 사례를 시스템에 적용하는 엔지니어링과 운영)할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.

# 신뢰성
- 소프트웨어의 경우 일반적인 기대치는 다음과 같다
  - 애플리케이션은 사용자가 기대한 기능을 수행한다.
  - 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.
  - 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
  - 시스템은 허가되지 않은 접근과 오남용을 방지한다.
- 이 모든 것이 "올바르게 동작함"을 의미하는 경우 대략 "무언가 잘못되더라도 지속적으로 올바르게 동작함"을 신뢰성의 의미로 이해할 수 있다.
- 잘못될 수 있는 일을 **결함**이라고 부른다. 그러한 결함을 예측하고 대처할 수 있는 시스템을 **내결함성 또는 탄력성**을 지녔다고 말한다.
  - 모든 종류의 결함을 견딜 수 있는 시스템을 설계하는건 불가능하다. 따라서 특정 유형의 결함 내성에 대해서만 이야기하는 것이 타당하다.
- 결함은 장애(failure)와 동일하지 않다.
  - 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의된다.
  - **장애**는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.
  - 결함 확률을 0으로 줄이는 것은 불가능하다. 따라서 대개 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 가장 좋다.
- 많은 중대한 버그는 미흡한 오류 처리에 기인한다. 고의적으로 결함을 유도함으로써 내결함성 시스템을 지속적으로 훈련하고 테스트해서 결함이 자연적으로 발생했을 때 올바르게 처리할 수 있다는 자신감을 높인다. 넷플릭스의 Chaos Monkey가 한 예이다.

### 하드웨어 결함
- 하드디스크가 고장 나고, 램에 결함이 생기고, 대규모 정전 사태가 발생하고, 누군가가 네트워크 케이블을 잘못 뽑는 것과 같은 결함을 말한다.
  - 규모가 큰 데이터센터에서 일하는 사람은 많은 장비를 다룰 경우 이 같은 일은 늘상 일어난다고 말한다.
- 하드디스크의 평균 장애 시간은 약 10 ~ 50년으로 보고됐다. 따라서 10,000개의 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한 개의 디스크가 죽는다고 예상해야 한다.
- 시스템 장애율을 줄이기 위한 첫 번째 대응으로 각 하드웨어 구성 요소에 중복을 추가하는 방법이 일반적이다.
  - 디스크는 RAID 구성으로 설치할 수 있고, 서버는 이중 전원 디바이스와 핫 스왑 가능한 CPU를 배치하는 등등
  - 이런 접근 방식은 하드웨어 문제로 장애가 발생하는 것을 완전히 막을 수는 없지만 이해하기 쉽고 보통 수년 간 장비가 중단되지 않고 계속 동작할 수 있게 한다.
- 최근까지 단일 장비의 전체 장애는 매우 드물기 때문에 대부분의 애플리케이션은 하드웨어 구성 요소의 중복으로 충분했다.
- 하지만 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 더 많은 애플리케이션이 많은 수의 장비를 사용하게 됐고, 이와 비례해 하드웨어 결함율도 증가했다.
  - 또한 AWS 같은 일부 클라우드 플랫폼은 가상 장비 인스턴스가 별도의 경고 없이 사용할 수 없게 되는 상황이 상당히 일반적이다.
- 따라서 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 점점 옮겨가고 있다.

### 소프트웨어 오류
- 보통 하드웨어 결함을 무작위적이고 서로 독립적이라고 생각한다. 즉 한 장비의 디스크에 장애가 있다고 해서 다른 장비의 디스크에 장애가 발생하지는 않는다는 뜻이다.
- 또 다른 부류의 결함으로 시스템 내 체계적 오류가 있다. 이 결함은 예상하기가 더 어렵고 노드 간 상관관계 때문에 상관관계가 없는 하드웨어 결함보다 오히려 시스템 오류를 더욱 많이 유발하는 경향이 있다.
  - 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 버그
  - CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
  - 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
  - 한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애
- 이 같은 소프트웨어 결함을 유발하는 버그는 특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않는다.
- 소프트웨어의 체계적 오류 문제는 신속한 해결책이 없다.
  - 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기, 빈틈없는 테스트, 프로세스 격리, 죽은 프로세스의 재시작 허용, 프로덕션에서 시스템 동작의 측정, 모니터링, 분석하기
  - 이와 같은 여러 작은 일들이 문제 해결에 도움을 줄 수 있다. 시스템이 뭔가를 보장하기 기대한다면 수행 중에 이를 지속적으로 확인해 차이가 생기는 경우 경고를 발생시킬 수 있다.
 
### 인적 오류
- 사람은 소프트웨어 시스템을 설계하고 구축하며, 운영자로서 시스템을 계속 운영한다. 이들이 최선의 의도를 갖고 있어도 사람은 미덥지 않다고 알려져 있다.
  - 대규모 인터넷 서비스에 대한 한 연구에 따르면 운영자의 설정 오류가 중단의 주요 원인인 반면 하드웨어 결함은 중단 원인의 10 ~ 25%에 그친다.
- 사람이 미덥지 않음에도 시스템을 신뢰성 있게 만들기 위해서는 다양한 접근 방식을 결합한다.
  - 오류의 가능성을 최소화하는 방향으로 시스템을 설계하라
  - 사람이 가장 많이 실수하는 장소(부분)에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리하라
  - 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트하라
  - 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있게 하라
  - 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라
  - 조작 교육과 실습을 시행하라. 까다롭지만 매우 중요한 측면이다.

### 신뢰성은 얼마나 중요할까?
- 신뢰성은 원자력 발전소나 항공 교통 관제 소프트웨어만을 위한 것이 아니다. 더 많은 수의 일상적인 애플리케이션도 안정적으로 작동해야 한다.
- "중요하지 않은" 애플리케이션도 사용자에 대한 책임이 있다.
- 증명되지 않은 시장을 위해 시제품을 개발하는 비용이나 매우 작은 이익률의 서비스를 운영하는 비용을 줄이려 신뢰성을 희생해야 하는 상황이 있다. 하지만 이 경우에는 비용을 줄여야 하는 시점을 매우 잘 알고 있어야 한다.

# 확장성
- 시스템이 현재 안정적으로 동작한다고 해서 미래에도 안정적으로 동작한다는 보장은 없다. 성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가다.
- 확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식이 아님을 주의하라.
  - "X는 확장 가능하다", "Y는 확장성이 없다" 같은 말은 의미가 없다. 확장성을 논한다는 것은 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?"와 "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?" 같은 질문을 고려한다는 의미다.

### 부하 기술하기
- 시스템의 현재 부하를 간결하게 기술해야 한다.
  - 부하는 부하 매개변수라 부르는 몇 개의 숫자로 나타낼 수 있다. 가장 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라진다.
  - 부하 매개변수로 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자, 캐시 적중률 등이 될 수 있다.
- 구체적인 Twitter의 사례 (2012년 11월에 공개된 데이터를 토대로)를 볼 때 트위터의 두 가지 동작은 다음과 같다
  - 트윗 작성 (평균 초당 4.6k 요청, 피크일 때 초당 12k 요청 이상)
  - 홈 타임라인 (초당 300k 요청)
- 단순히 초당 12,000건의 쓰기 처리는 상당히 쉽다. 하지만 트위터의 확장성 문제는 주로 트윗 양이 아닌 팬 아웃 때문이다.
  - 개별 사용자는 많은 사람을 팔로우하고 많은 사람이 개별 사용자를 팔로우한다. 이 동작을 구현하는 방법은 크게 두 가지다.
    - 트윗 작성은 간단히 새로운 트윗 전역 컬렉션에 삽입한다. 사용자가 자신의 홈 타임라인을 요청하면 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간 순으로 정렬해서 합친다.
    - 각 수신자용 트윗 우편함처럼 개별 사용자의 홈 타임라인 캐시를 유지한다. 사용자가 트윗을 작성하면 해당 사용자를 팔로우하는 사람을 모두 찾고 각자의 홈 타임라인 캐시에 새로운 트윗을 삽입한다.

<img width="345" alt="스크린샷 2025-07-01 오후 6 03 02" src="https://github.com/user-attachments/assets/8d4672bd-b653-4776-b17c-60f242c2b7c5" />
<img width="501" alt="스크린샷 2025-07-01 오후 6 04 03" src="https://github.com/user-attachments/assets/206f67e5-188e-4cef-92a1-2695fae9a64e" />

- 트위터의 첫 번째 버전은 접근 방식 1을 사용했다. 시스템이 홈 타임라인 질의 부하를 버텨내기 위해 고군분투해야 했고, 그 결과 접근 방식 2로 전환했다.
  - 평균적으로 트윗 게시 요청량이 홈 타임라인 읽기 요청량에 비해 수백 배 적기 때문에 접근 방식 2가 훨씬 더 잘 동작한다.
- 접근 방식 2의 불리한 점은 이제 트윗 작성이 많은 부가 작업을 필요로 한다는 점이다.
  - 평균적으로 트윗이 약 75명의 팔로워에게 전달되므로 초당 4.6k 트윗은 홈 타임라인 캐시에 초당 345k건의 쓰기가 된다.
  - 그러나 평균값은 사용자마다 팔로워 수가 매우 다르다는 사실을 가린다. 즉 일부 사용자는 팔로워가 3천만명이 넘는다.
- 트위터 사례에서 사용자당 팔로워의 분포는 팬 아웃 부하를 결정하기 때문에 확장성을 논의할 때 핵심 부하 매개변수가 된다.
- 트위터 일화의 최종 전개는 다음과 같다. 접근 방식 2가 견고하게 구현돼 트위터는 두 접근 방식의 혼합형으로 바꾸고 있다.

### 성능 기술하기
- 시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다.
  - 부하 매개변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
  - 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야할까?
- Hadoop 같은 일괄 처리 시스템은 보통 처리량(초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간)에 관심을 가진다.
  - 온라인 시스템에서 더 중요한 사항은 서비스 응답 시간이다.
- 클라이언트가 몇 번이고 반복해서 동일한 요청을 하더라도 매번 응답 시간이 다르다. 그러므로 응답 시간은 단일 숫자가 아니라 측정 가능한 값의 분포로 생각해야 한다.
- 모든 요청에 동일한 시간이 걸려야 한다고 생각하는 상황에도 다양한 값을 얻게 된다. 백그라운드 프로세스의 컨텍스트 스위치, 네트워크 패킷 손실과 TCP 재전송, 가비지 컬렉션 휴지, 디스크 읽기를 강제하는 페이지 폴트 등의 원인으로 인해
- 보고된 서비스 평균 응답 시간을 살피는 일은 일반적이다. (대개 산술 평균) 하지만 전형적인 응답 시간을 알고 싶다면 평균은 그다지 좋은 지표가 아니다. 얼마나 많은 사용자가 실제로 지연을 경험했는지 알려주지 않기 때문이다.
- 일반적으로 평균보다는 백분위를 사용하는 편이 더 좋다.
- 사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다면 중앙값이 좋은 지표다.
  - 사용자가 여러 개의 요청을 보내면 최소한 하나의 요청이 중앙값보다 느릴 확률이 50%보다 훨씬 높다.
- 특이 값이 얼마나 좋지 않은지 알아보려면 상위 백분위를 살펴보는 것도 좋다. 이때 사용하는 백분위는 95분위, 99분위, 99.9분위가 일반적이다.
- 꼬리 지연 시간으로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요하다.
  - 예를 들어 아마존은 내부 서비스의 응답 시간 요구사항을 99.9분위로 기술한다. 요청 1,000개 중 1개만 영향이 있음에도 말이다.
  - 보통 응답 시간이 가장 느린 요청을 경험한 고객들은 많은 구매를 해서 고객 중에서 계정에 가장 많은 데이터를 갖고 있어서다. 웹 사이트를 빠르게 제공하게끔 보장해 고객을 계속 행복하게 만드는게 중요하다.
- 반면 99.99분위를 최적화하는 작업에는 비용이 너무 많이 들어서 아마존이 추구하는 목표에 충분히 이익을 가져다주지 못한다고 여겨진다.
- 백분위는 서비스 수준 목표(SLO)와 서비스 수준 협약서(SLA)에 자주 사용하고 기대 성능과 서비스 가용성을 정의하는 계약서에도 자주 등장한다.
- 큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지한다. 서버는 병렬로 소수의 작업만 처리할 수 있기 때문에 소순의 느린 요청 처리만으로도 후속 요청 처리가 지체된다. 이 현상을 선두 차단이라 한다.
  - 서버에서 후속 요청이 빠르게 처리되더라도 이전 요청이 완료되길 기다리는 시간 때문에 클라이언트는 전체적으로 응답 시간이 느리다고 생각할 것이다. 이런 문제 때문에 클라이언트 쪽 응답 시간 측정이 중요하다.
- 시스템의 확장성을 테스트하려고 인위적으로 부하를 생성하는 경우 부하 생성 클라이언트는 응답 시간과 독립적으로 요청을 지속적으로 보내야 한다.

<img width="613" alt="스크린샷 2025-07-01 오후 7 01 04" src="https://github.com/user-attachments/assets/1c8115eb-544c-48e7-9ca8-e2a8f773b6db" />

### 부하 대응 접근 방식
- 부하 수준 1단계에서 적합한 아키텍처로는 10배의 부하를 대응할 수 없다.
- 사람들은 확장성과 관련해 용량 확장(scale-up), 규모 확장(scale-out)으로 구분해서 말하곤 한다. 다수의 장비에 부하를 분산하는 아키텍처를 비공유 아키텍처라 부른다.
  - 현실적으로 좋은 아키텍처는 실용적인 접근 방식의 조합이 필요하다. 예를 들어 적절한 사양의 장비 몇 대가 다량의 낮은 사양 가상 장비보다 훨씬 간단하고 저렴하다.
- 일부 시스템은 탄력적이다. 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다. 반면 그렇지 않은 시스템은 수동으로 확장해야 한다.
- 다수의 장비에 상태 비저장 서비스를 배포하는 일은 상당히 간단하다. 하지만 단일 노드에 상태 유지 데이터 시스템을 분산 설치하는 일은 아주 많은 복잡도가 추가적으로 발생한다.
  - 이런 이유로 확장 비용이나 데이터베이스를 분산으로 만들어야 하는 고가용성 요구가 있을 때 까지 단일 노드에 데이터베이스를 유지하는 것이 최근까지의 통념이다.
- 분산 시스템을 위한 도구와 추상화가 좋아지면서 이 통념이 적어도 일부 애플리케이션에서는 바뀌었다. 대용량 데이터와 트래픽을 다루지 않는 사용 사례에도 분산 데이터 시스템이 향후 기본 아키텍처로 자리 잡을 가능성이 있다.
- 대개 대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션 특화돼 있다. 범용적이고 모든 상황에 맞는 확장 아키텍처는 없다.
- 특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다. 이 가정은 곧 부하 매개변수가 된다.

# 유지보수성
- 소프트웨어 비용의 대부분은 초기 개발이 아니라 지속해서 이어지는 유지보수에 들어가는 사실은 잘 알려져 있다.
- 여전히 소프트웨어 시스템상에서 일하는 많은 사람은 소위 레거시 시스템 유지보수 작업을 좋아하지 않는다.
- 유지보수 중 고통을 최소화하고 레거시 소프트웨어를 직접 만들지 않게끔 소프트웨어를 설계할 수 있다. 그러기 위해 주의를 기울여야 할 소프트웨어 시스템 설계 원칙은 다음과 같다.
  - 운용성: 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라
  - 단순성: 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라 (UI의 단순성과는 다르다는 점에 유의)
  - 발전성: 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라.
 
### 운용성: 운영 편리함 만들기
- 운영 중 일부 측면은 자동화할 수 있고 또 자동화해야 한다. 그러나 자동화를 처음 설정하고 제대로 동작하는지 확인하는 일은 여전히 사람의 몫이다.
- 시스템이 지속해서 원활하게 작동하려면 운영팀이 필수다. 좋은 운영팀은 일반적으로 다음과 같은 작업 등을 책임진다.
  - 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
  - 시스템 장애, 성능 저하 등의 문제의 원인을 추적
  - 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
  - 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
  - 미래에 발생한 가능한 문제를 예측해 문제가 발생하기 전에 해결
  - 배포, 설정 관리 등을 위한 모범 사례와 도구들 마련
  - 애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보수 태스크를 수행
  - 설정 변경으로 생기는 시스템 보안 유지보수
  - 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
  - 개인 인사 인동에도 시스템에 대한 조직의 지식을 보존함
- 좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미다.
  - 좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공
  - 표준 도구를 이용해 자동화와 통합을 위한 우수한 자원을 제공
  - 개별 장비 의존성을 회피, 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속 운영 가능해야 함
  - 좋은 문서와 이해하기 쉬운 운영 모델 제공
  - 만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여
  - 적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함
  - 예측 가능하게 동작하고 예기치 않은 상황을 최소화함

### 단순성: 복잡도 관리
- 소규모 소프트웨어 프로젝트에서는 간단하고 표현이 풍부한 코드로 말끔하게 시스템을 작성할 수 있지만 프로젝트가 커짐에 따라 시스템은 매우 복잡하고 이해하기 어려워진다.
- 복잡도 때문에 시스템 유지보수가 어려울 때 예산과 일정이 초과되곤 한다. 따라서 단순성이 구축하려는 시스템의 핵심 목표여야 한다.
- 시스템을 단순하게 만드는 일이 반드시 기능을 줄인다는 의미는 아니다. 우발적 복잡도를 줄이다는 뜻일 수도 있다.
  - 소프트웨어가 풀어야 할 (사용자에게 보이는) 문제에 내재하고 있지 않고 구현에서만 발생하는 것
- 우발적 복잡도를 제거하기 위한 최상의 도구는 추상화다. 좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.
- 예를 들어 고수준 프로그래밍 언어는 기계 언어, CPU 레지스터, 시스템 호출을 숨긴 추상화다. SQL은 디스크에 기록하고 메모리에 저장한 복잡한 데이터 구조와 다른 클라이언트의 동시 요청과 고장 후 불일치를 숨긴 추상화다.
- 하지만 좋은 추상화를 찾기는 매우 어렵다. 분산 시스템 분야에는 여러 좋은 알고리즘이 있다. 하지만 관리 가능한 수준에서 시스템 복잡도를 유지하는 데 도움이 되는 추상화로 이런 알고리즘을 묶는 방법은 명확하지 않다.

### 발전성: 변화를 쉽게 만들기
- 시스템의 요구사항이 영원히 바뀌지 않을 가능성은 매우 적다
- 조직 프로세스 측면에서 애자일 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공한다. 또한 TDD와 리팩토링 같이 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이되는 기술 도구와 패턴을 개발하고 있다.
- 이런 애자일 기법에 대한 설명은 대부분 매우 작고, 로컬 규모에 초점을 맞추고 있다. 이 책에서는 다양한 애플리케이션이나 다른 특성을 가진 서비스로 구성된 대규모 데이터 시스템 수준에서 민첩성을 높이는 방법을 찾는다.
