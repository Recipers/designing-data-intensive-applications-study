# PART 1. 데이터 시스템의 기초
- 데이터 시스템이 단일 장비거나 여러 클러스터 장비에 분산됐거나 상관없이 모든 상황에서 적용되는 기본 개념
    - 1장 : 책 전반에 사용되는 전문 용어와 접근 방식
        - 신뢰성, 확장성, 유지보수성
    - 2장 : 다양한 데이터 모델과 질의 언어를 비교
        - 개발자 관점에서 데이터베이스를 가장 가시적으로 구별할 수 있는 요소
    - 3장 : 저장소 엔진의 내부와 데이터베이스가 디스크에 어떻게 데이터를 배치하는지 알아봄
        - 다양한 저장소 엔진은 서로 다른 작업부하에 맞춰 최적화됨
        - 올바른 저장소 엔진을 선택하는 것은 성능에 큰 영향을 줌
    - 4장 : 다양한 데이터 부호화 포맷을 비교
        - 애플리케이션이 요구사항이 변경되고 시간이 지남에 따라 스키마를 변경해야 하는 환경에서 어떻게 사용되는지 살펴봄

# 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
- 오늘날 많은 애플리케이션은 계산 중심과는 다르게 데이터 중심적
    - CPU 성능은 애플리케이션을 제한하는 요소는 아님
    - 더 큰 문제는 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도
- 일반적으로 데이터 중심 애플리케이션은 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소로 만듬
    - 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장 (데이터베이스)
    - 읽기 속도 향상을 위해 값비싼 수행 결과를 기억 (캐시)
    - 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공 (검색 색인)
    - 비동기 처리를 위해 다른 프로세스로 메시지 보내기 (스트림 처리)
    - 주기적으로 대량의 누적된 데이터를 분석 (일괄 처리)
- 많은 생각 없이 사용할 수 있게 데이터 시스템이 성공적으로 추상화됨
- 애플리케이션마다 요구사항이 다르고, 데이터베이스가 다양한 특성을 가지고 있음
    - 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 함
- 데이터 시스템의 원칙, 실용성, 이를 활용한 데이터 중심의 애플리케이션을 개발하는 방법을 책에서 담고 있음
## 데이터 시스템에 대한 생각
- 일반적으로 데이터베이스, 큐, 캐시 등을 매우 다른 범주에 속하는 도구로 생각함
- 표면적으로 비슷하더라도 매우 다른 접근 패턴을 갖고 있어 서로 다른 성능 특성이 있기 때문에 구현 방식이 매우 다름
- 데이터 저장과 처리를 위한 여러 새로운 도구는 최근에 만들어짐
    - 새로운 도구는 다양한 사용 사례에 최적화되었기 때문에 전통적인 분류에 들어맞지 않음
        - 메시지 큐로 사용하는 레디스
        - 지속성을 보장하는 메시지 큐인 아파치 카프카
    - 분류 간 경계가 흐려짐
- 점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 갖고 있음
- 작업은 단일 도구에서 효율적으로 수행할 수 있는 태스크로 나누고 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결
    - 메인 데이터베이스와 분리된 캐시 계층이나, 앨라스틱서치나 솔라 같은 전문 검색 서버의 경우, 메인 데이터베이스와 동기화된 캐시나 색인을 유지하는 것은 애플리케이션 코드의 책임임
- 서비스 제공을 위해 각 도구를 결합할 때 서비스 인터페이스나 애플리케이션 프로그래밍 인터페이스(API)는 보통 구현 세부 사항을 숨김
- 기본적으로 좀 더 작은 범용 구성 요소들로 새롭고 특수한 목적의 데이터 시스템을 만듬
- 복합 데이터 시스템은 외부 클라이언트가 일관된 결과를 볼 수 있게끔 쓰기에서 캐시를 올바르게 무효화하거나 업데이트하는 등의 특정 보장 기능을 제공함
    - 개발자는 데이터 시스템의 설계자이기도 함
- 데이터 시스템이나 서비스를 설계할 때 까다로운 문제가 많이 생김
    - 내부적으로 문제가 있어도 데이터를 정확하고 완전하게 유지하려면?
    - 시스템의 일부 성능이 저하되더라도 클라이언트에 일관되게 좋은 성능을 제공하려면?
    - 부하 증가를 다루기 위해 어떤 규모를 확장할까?
    - 서비스를 위해 좋은 API는 어떤 모습?
- 관련자의 기술 숙련도, 기존 시스템의 의존성, 전달 시간 척도, 다양한 종류의 위험에 대한 조직의 내성, 규제 제약 등은 시스템 설계에 영향을 줄 수 있는 요소
- 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사
    - 신뢰성
        - 하드웨어나 소프트웨어 결함, 인적 오류 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작해야 함
        - 올바르게 동작 : 원하는 성능 수준에 서 정확한 기능을 수행
    - 확장성
        - 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 함
    - 유지보수성
        - 시간이 지남에 따라 여러 다양한 사람들이 시스템상에서 작업할 것
        - 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 함
## 신뢰성
- 소프트웨어의 일반적인 기대치
    - 애플리케이션은 사용자가 기대한 기능을 수행한다
    - 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다
    - 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다
    - 시스템은 허가되지 않은 접근과 오남용을 방지
- 무언가 잘못되더라도 지속적으로 올바르게 동작함
- 잘못될 수 있는 일을 결함이라고 부름
- 결함을 예측하고 대처할 수 있는 시스템을 **내결합성** 또는 **탄력성**을 지녔다고 말함
    - 내결합성은 모든 종류의 결함을 견딜 수 있는 시스템을 만들수 있음을 시사하지만 실제로는 실현 불가능, 특정 유형에 대한 결함 내성을 의미
- 결함과 장애는 동일하지 않음
    - 결함 : 사양에서 벗어난 시스템의 한 구성 요소
    - 장애 : 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우
- 반직관적이지만 내결함성 시스템에서 경고 없이 개별 프로세스를 무작위로 죽이는 것과 같이 고의적으로 결함을 을으켜 결함률을 증가시키는 방법은 납득할만 함
    - 고의적으로 결함을 유도함으로써 내결함성 시스템을 지속적으로 훈련하고 테스트해서 결함이 자연적으로 발생했을 때 올바르게 처리
    - 넷플릭스 카오스 몽키
### 하드웨어 결함
- 시스템 장애의 원인을 생각할 때 하드웨어 결함이 바로 떠오름
    - 렘 결함
    - 대규모 정전 사태
    - 네트워크 케이블 잘못 뽐음 등
- 하드디스크의 평균 장에 시간 은 약 10~50년으로 보고됨
- 10,000개의 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한 개의 디스크가 죽는다고 예상
- 시스템 장애율을 줄이기 위한 첫 번째 대응으로 각 하드웨어 구성 요소에 중복을 추가하는 방법이 일반적
    - 구성 요소 하나가 죽으면 고장 난 구성 요소가 교체되는 동안 중복된 구성 요소를 대신 사용
    - 문제가 발생하는 것을 완벽히 막을 순 없지만, 수년 간 장비가 중단되지 않고 계속 동작할 수 있게 함
- 단일 장비의 전체 장에는 매우 드물기 때문에 대부분의 애플리케이션은 하드웨어 구성 요소의 중복으로 충분했음
    - 장애 발생 시 중단간은 대부분의 애플리케이션에 치명적이지 않음
    - 다중 장비 중복은 고가용성이 절대적으로 필수적인 소수의 애플리케이션에서만 필요했었음
- 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 많은 수의 장비를 사용하게 되었음 
    - 하드웨어 결함율 증가
    - 아마존 웹 서비스(AWS) 클라우드 플랫폼은 가상 장비 인스턴스가 별도의 경고 없이 사용할 수 없게 되는 상황이 상당히 일반적
    - 이런 플랫폼은 단일 장비 신뢰성보다 유연성과 탄력성을 우선적으로 처리하게끔 설계됐기 때문
- 소프트웨어 내결함성 기술을 사용하거나 하드웨어 증복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 점점 옮겨가고 있음
    - 장비를 재부팅해야 하는 경우 
        - 단일 서버 시스뎀은 계획된 중단시간이 필요
        - 장비 장애를 견딜 수 있는 시스템은 전체 시스템의 중단시간 없이 한 노드씩 패치 가능
### 소프트웨어 오류
- 하드웨어 결함을 무작위적이고 서로 독립적이라고 생각
    - 한 장비의 디스크에 장애가 있다고 해서 다른 장비의 디스크에 장애가 발생하지는 않음
- 시스템 내 체계적 오류
    - 예상하기 더 어려움
    - 노드 간 상관관계 때문에 하드웨어 결함보다 시스템 오류를 많이 유발함
        - 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그
        - CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
        - 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
        - 연쇄 장애
- 특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않음
- 신속한 해결책이 없음
- 문제 해결에 도움이 되는 일들
    - 시스템의 가정과 상호작용에 대해 주의깊게 생각하기
    - 빈틈없는 테스트
    - 프로세스 격리
    - 죽은 프로세스의 재시작 허용
    - 프로덕션 환경에서 시스템 동작 측정
    - 모니터링
    - 분석하기
### 인적 오류
- 사람은 소프트웨어 시스템을 설계하고 구축, 운영함
    - 최선의 의도가 있어도 사람은 미덥지 않다
    - 운영자의 설정 오류가 중단의 주요 원인, 하드웨어 결함은 10~25%
- 신뢰성있는 최고의 시스템의 다양한 접근 방식
    - 오류의 가능성을 최소화하는 방향으로 시스템을 설계
    - 사람이 가장 많이 실수하는 장소에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리
        - 비 프로덕션 샌드박스 제공
    - 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트
        - 코너 케이스를 다루는데 유용
    - 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있게 하라
    - 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책 마련
    - 조작 교육과 실습
### 신뢰성은 얼마나 중요할까?
- 신뢰성은 일상적인 애플리케이션도 안정적으로 작동해야 함
    - 버그는 생산성 저하의 원인
- 중요하지 않은 애플리케이션도 사용자에 대한 책임이 있음
- 비용을 줄이려면 신뢰성을 희생해야 하는 상황이 있음
    - 비용을 줄여야 하는 시점을 잘 알고 있어야 함
## 확장성
- 시스템이 현재 안정적으로 동작한다고 미래에도 안정적으로 동작한다는 보장이 없음
- 성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가
- 확장성은 증가하느 부하에 대처하는 시스템 능력을 설명하는데 사용하는 용어
    - 시스템에 부여하는 일차원적인 표식이 아님
### 부하 기술하기
- 시스템의 현재 부하를 간결하게 기술해야 함
- 부하 매개변수라 부르는 몇 개의 숫자로 나타낼 수 있음
    - 적합한 부하 매개변수 선택은 시스템의 설계에 따라 다름
        - 웹 서버의 초당 요청 수
        - 데이터베이스의 읽기 대 쓰기 비율
        - 대화방의 동시 활성 사용자
        - 캐시 적중률
    - 평균적인 경우가 중요할 수도 있고, 소수의 극닥적인 경우가 병목 현상의 원인일 수 있음
- 트위터
    - 주요 동작
        - 트윗 작성
        - 홈 타인라인
    - 단순히 초당 12,000의쓰기 처리는 쉬움
    - 팬 아웃 때문에 확장성 문제 발생
    - 개별 사용자는 많은 사람을 팔로우하고 많은 사람이 개별 사용자를 팔로우 함
        1. 트윗 작성은 간단히 새로운 트윗을 전역 컬렉션에 삽입.
            - 사용자가 홈 타임라인을 요청하면 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간순으로 정렬해서 합침
        2. 각 수신 사용자용 트윗 우편함처럼 개별 사용자의 홈 타임라인 캐시를 유지함
            - 사용자가 트윗을 작성하면 해당 사용자를 팔로우하는 사람을 모두 찾고 각자의 홈 타임라인 캐시에 새로운 트윗 삽입
            - 홈 타임라인의 읽기 요청은 요청 결과를 미리 계산했기 때문에 비용 저렴
    - 1번 방법으로 하면 시스템이 홈 타임라인 질의 부하를 버텨내기 어려웠고 2로 전환함
    - 2번 방법은 트윗 작성이 많은 부가 작업을 필요로 함
    - 두 접근 방식의 혼합형으로 바꾸고 있음
- 애플리케이션마다 특성은 다르지만 부하에 대한 추론에 비슷한 원리를 적용할 수 있음
### 성능 기술하기
- 시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있음
    - 부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까
    - 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까
    - 두 질문 모두 성능 수치가 필요함
- 하둡 같은 일괄 처리 시스템은 보통 처리랴엥 관심을 가짐
- 온라인 시스템에서 더 중요한 사항은 서비스 응답시간
    - 클라이언트가 매번 동일한 요청을 하더라도 응답시간이 다름
    - 응답 시간은 단일 숫자가 아니라 측정 가능한 값의 분포로 생각해야 함
- 대부분 요청은 빠르지만 가끔 오래 걸리는 특이 값이 있음
    - 느린 요청은 더 많은 데이터를 처리하기 때문에 본질적으로 더 비쌀 수도 있음
- 추가 지연이 생기는 여러 원인
    - 백그라운드 프로세스의 컨텍스트 스위치
    - 네트워크 패킷 손실과 TCP 재전송
    - 가비지 컬렉션 휴지
    - 디스크에서 읽기를 강제하는 페이지 폴트
    - 서버 랙의 기계적인 진동 등
- 서비스 평균 응답 시간을 살피는 일은 일반적
    - 전형적인 응답시간을 알고 싶다면 평균은 그다지 좋은 지표가 아님
    - 얼마나 많은 사용자가 지연을 경험했는지 알려주지 않음
- 평균보다는 백분위를 사용하는 편이 더 좋음
- 응답 시간 목록을 가지고 가장 빠른 시간부터 제일 느린 시간까지 정렬하면 중간 지점이 중앙값이 됨
- 사용자가 보통 얼마나 오랫동안 기다려야하는지 알고 싶다면 중앙값이 좋은 지표
- 중앙값(50분위, p50)은 단일 요청을 참고함
- 최소한 하나의 요청이 중앙값보다 느릴 확률이 50%보다 훨씬 높음
- 꼬리 지연 시간으로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요함
    - 아마존은 내부 서비스의 응답 시간 요구사항을 99.9 분위로 기술함
    - 요청 1,000개 중 1개만 영향이 있음
    - 99.99분위를 최적화하는 작업에는 비용이 너무 많이 들음
    - 아마존이 추구하는 목표에 충분히 이익을 가져다주지 못한다고 여겨짐
- 백분위는 서비스 수준 목표(SLO)와 서비스 수준 협약서(SLA)에 자주 사용하고 기대 성능과 서비스 가용성을 정의하는 계약서에도 자주 등장
- 큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지함
    - 서버는 병렬로 소수의 작업만 처리할 수 있음
    - 소수의 느린 요청처리만으로도 후속 요청 처리가 지체됨, 선두 차단
    - 서버에서 후속 요청이 빠르게 처리되더라도 이전 요청이 완료되길 기다리는 시간때문에 클라이언트는 전체적으로 응답 시간이 느리다고 생각
    - 클라이언트 쪽 응답 시간 측정이 중요함
- 시스템의 확장성을 테스트하려고 인위적으로 부하를 생성하는 경우 부하 생성 클라이언트는 응답 시간과 독립적으로 요청을 지속적으로 보내야 함
    - 다음 요청을 보내기 전에 이전 요청이 완료되길 기다리면 테스트에서 인위적으로 대기 시간을 실제보다 더 짧게 만들어 평가를 왜곡
### 부하 대응 접근 방식
- 급성장하는 서비스를 맡고 있다면 부하 규모의 자릿수가 바뀔 때마다 아키텍처를 재검토해야 할 수도 있음
- 용량 확장(수직 확장, scaling up)
    - 좀 더 강력한 장비로 이동
- 규모 확장(수평 확장, scaling out)
    - 다수의 낮은 사양 장비에 부하를 분산
    - 비공유 아키텍처
- 일부 시스템은 탄력적임
    - 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있음
    - 그렇지 않은 시스템은 수동으로 확장해야됨
    - 탄력적인 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용
    - 수동으로 확장하는 시스템은 간단하고 운영상 예상치 못한 일이 더 적음
- 다수의 장비에 상태 비저장 서비스를 배포하는 일은 간단함
- 단일 노드에 상태 유지 데이터 시스템을 분산 설치하는 일은 아주 많은 복잡도가 추가로 발생함
- 분산 시스템을 위한 도구와 추상화가 좋아지면서 이 통념이 적어도 일부 애플리케이션에서는 바뀌었음
    - 향후 기본 아키텍처로 자리잡을 가능성이 있음
- 대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특화되어 있음
- 범용적이고 모든 상황에 맞는 확장 아키텍처는 없음
- 아키텍처를 결정한느 요소
    - 읽기의 양
    - 쓰기의 양
    - 저장할 데이터의 양
    - 데이터의 복잡도
    - 응답 시간 요구사항
    - 접근 패턴
- 특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축함
    - 이 가정이 곧 부하 매개변수가 됨
    - 초기 단계나 검증되지 않은 제품의 경우에 미래를 가정한 부하에 대비해 확장하기보다 빠르게 반복해서 제품 기능을 개선하는 작업이 중요함
## 유지보수성
- 소프트웨어 비용의 대부분은 초기 개바이 아니라 지속해서 이어지는 유지보수에 들어감
- 유지보수
    - 버그 수정
    - 시스템 운영 유지
    - 장애 조사
    - 새로운 플랫폼 적응
    - 새 사용 사례를 위한 변경
    - 기술 채무 상환
    - 새로운 기능 추가 등
- 레거시 시스템 유지보수 작업을 다들 좋아하지 않음
- 레거시 소프트웨어를 직접 만들지 않게끔 소프트웨어를 설계할 수 있음
    - 운용성
        - 운영팀이 시스템을 원할하게 운영할 수 있게 쉽게 만들어라
    - 단순성
        - 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라
    - 발전성
        - 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 해라
        - 유연성, 수정 가능성, 적응성으로 알려져 있음
- 신뢰성, 확장성을 달성하기 위한 쉬운 해결책은 없음
- 그보다 운용성, 단순성, 발전성을 염두에 두고 시스템을 생각해야 함
### 운용성: 운영의 편리함 만들기
- 운영 중 일부 측면은 자동화할 수 있고 또 자동화해야 함
- 시스템이 지속해서 원활하게 작동하려면 운영팀 이 필수 
- 운영팀 책임
    - 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
    - 시스템 장애, 성능 저하 등의 문제의 원인을 추적
    - 보안 패치를 포합해 소프트웨어와 플랫폼을 최신 상태로 유지
    - 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
    - 미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결
    - 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련
    - 애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복집한 유지보수 태스크를 수행
    - 설정 변경으로 생기는 시스템 보안 유지보수
    - 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
    - 개인 인사 이동에도 시스템에 대한 조직의 지식을 보존함
- 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미 
- 동일 반복 태스크를 쉽게 하기 위한 일들
    - 좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공
    - 표준 도구를 이용해 자동화와 통합을 위한 우수한 지원을 제공
    - 개별 창비 의존성을 회피. 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함
    - 좋은 문서와 이해하기 쉬운 운영 모델
    - 만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여
    - 적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함
    - 예측 가능하게 동작하고 예기치 않은 상황을 최소화함
### 단순성: 복잡도 관리
- 소규모 소프트웨어 프로젝트에서는 간단하고 표현이 풍부한 코드로 말끔하게 시스템 작성 가능
    - 프로젝트가 커짐에 따라 시스템은 매우 복잡하고 이해하기 어려워짐
- 복잡도는 같은 시스템에서 작업해야 하는 모든 사람의 진행을 느리게 하고 나아가 유지보수 비용이 증가함
    - 커다란 진흙 덩어리로 묘사
- 복잡도는 다양한 증상으로 나타남
    - 상태 공간의 급증
    - 모듈 간 강한 커플링
    - 복잡한 의존성
    - 일관성 없는 명명과 용어
    - 성능 문제 해결을 목표로 한 해킹
    - 임시방편으로 문제를 해결한 특수 사례 등
- 복잡도 때문에 시스템 유지보수가 어려울 때 예산과 일정이 초과됨
    - 복잡한 소프트웨어에서는 변경이 있을 때 버그가 생길 위험이 더 큼
    - 개발자가 숨겨진 가정과 의도치 않은 결과 및 예기치 않은 상호작용을 간과하기 쉬움
    - 복잡도를 줄이면 유지보수성이 크게 향상됨
    - 단순성이 구축하려는 시스템의 핵심 목표여야 함
- 시스템을 단순하게 만드는 일이 기능을 줄인다는 의미는 아님
    - 우발적 복잡도를 줄인다는 뜻
- 우발적 복잡도를 제거하기 위한 최상의 도구는 추상화
    - 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있음
    - 다양한 애플리케이션에서도 사용 가능함
    - 재사용은 재구현하는것보다 효율적이고 고품질 소프트웨어로 이어짐
- 좋은 추상화를 찾기는 매우 어려움
### 발전성: 변화를 쉽게 만들기
- 시스템의 요구사항이 영원히 바뀌지 않을 가능성은 매우 적음
    - 끊임없이 변할 가능성이 훨씬 큼
- 조직 프로세스 측면에서 애자일 작업 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공함
    - 테스트 주도 개발과 리팩토링 같이 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이 되는 기술 도구와 패턴을 개발하고 있음
- 데이터 세스템 변경을 쉽게 하고 변화된 요구 사항에 시스템을 맞추는 방법은 시스템의 간단함과 추상화와 밀접한 관련이 있음
